##############################################################################
# --- IMPORT DEPENDENCIES -------------------------------------------------- #
##############################################################################
# Third-party imports
import numpy as np
import vtk
import vtk.util.numpy_support  # type: ignore  # pylint: disable=E0401,E0611

# Custom package and module imports
from mahautils.utils.vartools import list_search, max_list_item_len
from .exceptions import VTKFormatError
from .files import BinaryFile


##############################################################################
# --- VTK READER/WRITER ---------------------------------------------------- #
##############################################################################
class VTK(BinaryFile):
    class PointData:
        def __init__(self, dtype: str, data: np.array):
            if dtype not in ['scalar', 'vector']:
                raise ValueError(f'Point data type "{dtype}" is not supported')
            self.type = dtype

            self.data = np.array(data)

        def __str__(self) -> str:
            if self.type == 'scalar':  # pylint: disable=R1705
                return '<SCALAR>'
            elif self.type == 'vector':
                return '<VECTOR>'
            else:
                return '<UNKNOWN>'

        def __repr__(self) -> str:
            return f'PointData {self.__str__()} object'

    def __init__(self, file: str = None) -> None:
        super().__init__()

        # Declare variables
        self._num_points: int = None
        self._point_coordinates: list = None
        self._point_data: dict = {}

        # If file is specified, read the file
        if file is not None:
            self.read(file)

    @property
    def coordinates(self):
        """Returns a dictionary containing mesh coordinates of VTK point"""
        coordinates = np.array(self._point_coordinates)
        return {
            'x': coordinates[:, 0],
            'y': coordinates[:, 1],
            'z': coordinates[:, 2],
            'array': np.array(coordinates),
        }

    @property
    def point_data(self):
        """Returns a dictionary containing all VTK point data"""
        return self._point_data

    @property
    def point_data_names(self):
        """Returns the names of each point data field in the VTK file"""
        return list(self._point_data.keys())

    def __print_field(self, key: str, indent: int = 0):
        if key not in self._point_data:
            raise KeyError(f'Unknown point data field "{key}"')

        len_field = max_list_item_len(self.point_data_names)
        pointdata_type = f"[{self._point_data[key].type}]"

        print(' ' * indent, end='')
        print(f"""{key:{len_field+4}s} {pointdata_type}""")

    def read(self, file: str):
        """Reads and parses a VTK file

        Read and extracts point data from a VTK file generated by the Maha
        Multics software
        """
        # Read VTK file
        reader = vtk.vtkDataSetReader()  # pylint: disable=E1101
        reader.SetFileName(file)
        reader.ReadAllFieldsOn()
        reader.ReadAllScalarsOn()
        reader.ReadAllVectorsOn()
        reader.ReadAllTensorsOn()
        reader.Update()
        output = reader.GetOutput()

        # Determine number of points
        self._num_points = output.GetNumberOfPoints()

        # Extract point coordinates
        self._point_coordinates = [
            output.GetPoint(i) for i in range(self._num_points)
        ]

        # Extract point data
        point_data = output.GetPointData()
        for i in range(point_data.GetNumberOfArrays()):
            # Extract data from VTK file
            name = point_data.GetArray(i).GetName()
            array = vtk.util.numpy_support.vtk_to_numpy(point_data.GetArray(i))  # pylint: disable=E1101  # noqa: E501

            # Verify data have expected format
            if array.ndim == 2:
                if not array.shape[1] == 3:
                    raise VTKFormatError(f'VTK vector data "{name}" has '
                                         f'{array.shape[1]} components, which '
                                         f'does not match expected number of '
                                         f'componets (3)')
            elif array.ndim != 1:
                raise VTKFormatError(f'VTK point data field "{name}" has '
                                     f'dimensions {array.shape}, which does '
                                     f'not match expected format')

            if len(array) != self._num_points:
                raise VTKFormatError(f'VTK point data field "{name}" has '
                                     f'{len(array)} elements, which does not '
                                     f'match number of VTK mesh points '
                                     f'({self._num_points})')

            # Store point data
            if array.ndim == 1:
                dtype = 'scalar'
            else:
                dtype = 'vector'

            self._point_data[name] = self.PointData(dtype, array)

    def get_data(self, field: str) -> np.ndarray:
        return self._point_data[field].data

    def get_type(self, field: str) -> str:
        return self._point_data[field].type

    def search(self, name: str, case_sensitive: bool = False,
               print_results: bool = True, return_results: bool = False):
        if name in self.point_data_names:
            if print_results:
                print(f'Found point data field "{name}":')
                self.__print_field(name, indent=4)

            if return_results:
                return {
                    'match_found': True,
                    'matches': [name],
                }

        else:
            if print_results:
                print(f'Unable to find "{name}"')

            if return_results:
                output_dict = {'match_found': False}

            matches = list_search(name, self.point_data_names, case_sensitive)
            if len(matches) > 0:
                if print_results:
                    print(f'\nThe following fields contain "{name}":')
                    for var in matches:
                        self.__print_field(var, indent=4)

                if return_results:
                    output_dict['matches'] = list(matches)

            if return_results:
                return output_dict

    def search_noninteractive(self, name: str,
                              case_sensitive: bool = False) -> dict:
        return self.search(name, case_sensitive, False, True)
